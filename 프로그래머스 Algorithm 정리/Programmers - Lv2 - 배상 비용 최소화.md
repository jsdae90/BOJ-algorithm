### Programmers - Lv2 - 배상 비용 최소화

#### 문제 설명

---

OO 조선소에서는 태풍으로 인한 작업지연으로 수주한 선박들을 기한 내에 완성하지 못할 것이 예상됩니다. 기한 내에 완성하지 못하면 손해 배상을 해야 하므로 남은 일의 작업량을 숫자로 매기고 배상비용을 최소화하는 방법을 찾으려고 합니다.

***배상 비용은 각 선박의 완성까지 남은 일의 작업량을 제곱하여 모두 더한 값이 됩니다.\***

조선소에서는 1시간 동안 남은 일 중 하나를 골라 작업량 1만큼 처리할 수 있습니다. 조선소에서 작업할 수 있는 N 시간과 각 일에 대한 작업량이 담긴 배열(works)이 있을 때 배상 비용을 최소화한 결과를 반환하는 함수를 만들어 주세요. 예를 들어, N=4일 때, 선박별로 남은 일의 작업량이 works = [4, 3, 3]이라면 배상 비용을 최소화하기 위해 일을 한 결과는 [2, 2, 2]가 되고 배상 비용은
2<sup>2</sup> + 2<sup>2<sub> + 2<sup>2<sub> = 12 가 되어 12를 반환해 줍니다.



#### 제한 사항

---

- 일할 수 있는 시간 N : 1,000,000 이하의 자연수
- 배열 works의 크기 : 1,000 이하의 자연수
- 각 일에 대한 작업량 : 1,000 이하의 자연수



#### 입출력 예

---

| N    | works     | result |
| ---- | --------- | ------ |
| 4    | [4, 3, 3] | 12     |
| 2    | [3, 3, 3] | 17     |



#### 입출력 예 설명

---

1. 문제의 예제와 같습니다

2. 배상 비용을 최소화하기 위해 일을 한 결과는 [2, 2, 3]가 되고 배상 비용은 
   2<sup>2<sub> + 2<sup>2<sub> + 3<sup>2<sub> = 17 가 되어 17를 반환해 줍니다.



#### 제출 코드

---

```python
import heapq

def solution(N, works):
    if N > sum(works) :
        return 0
    works = [(-i, i) for i in works]
    heapq.heapify(works)
    for _ in range(N) :
        w = heapq.heappop(works)[1] - 1
        heapq.heappush(works, (-w, w))
    return sum([i[1]**2 for i in works])
```

해당 문제를 통해, min heap을 max heap으로 이용하기 위해 `(-i, i)`를 사용함을 알게 되었다.

또한, 피드백을 통해 return 부분의 코드를 더욱 간결하게 작성했다.



#### 문제 풀이

---

가장 먼저, 예외 처리와 같이 sum(works)보다 N이 크다면, 모든 작업량을 소진하여
0<sup>2<sub> + 0<sup>2<sub> = 0 이 되기 때문에, 0을 return해준다.

N이 더 작을 경우, 문제 해결에 max heap을 사용하기 위해 works의 요소들을 `(-i, i)`로 변환한다.

그 후, heap을 적용하여 works를 max heap으로 적용시키며

N만큼 반복문을 돌며 N을 돌때마다 1시간의 작업량 부분이기에, (-i, i)중 실제 작업량을 표현하는

`works[n][1]`을 가져와 -1시간을 취해 작업량을 감소해주고,

수정된 값으로 works에 값을 다시 취한다.

이후, 남은 작업량에 제곱을 취해 모두 더한 값을 return한다.
