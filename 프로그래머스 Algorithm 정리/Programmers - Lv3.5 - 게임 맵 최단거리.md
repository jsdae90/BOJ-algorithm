### Programmers - Lv3.5 - 게임 맵 최단거리

#### 문제설명

---

ROR 게임은 두 팀으로 나누어서 진행하며, 상대 팀 진영을 먼저 파괴하면 이기는 게임입니다. 따라서, 각 팀은 상대 팀 진영에 최대한 빨리 도착하는 것이 유리합니다.

지금부터 당신은 한 팀의 팀원이 되어 게임을 진행하려고 합니다. 다음은 5 x 5 크기의 맵에, 당신의 캐릭터가 (행: 1, 열: 1) 위치에 있고, 상대 팀 진영은 (행: 5, 열: 5) 위치에 있는 경우의 예시입니다.

<img src="https://res.cloudinary.com/jistring93/image/upload/v1482130533/%EC%B5%9C%EB%8B%A8%EA%B1%B0%EB%A6%AC1_sxuruo.png">

위 그림에서 검은색 부분은 벽으로 막혀있어 갈 수 없는 길이며, 흰색 부분은 갈 수 있는 길입니다. 캐릭터가 움직일 때는 동, 서, 남, 북 방향으로 한 칸씩 이동하며, 게임 맵을 벗어난 길은 갈 수 없습니다.
아래 예시는 캐릭터가 상대 팀 진영으로 가는 두 가지 방법을 나타내고 있습니다.

- 첫 번째 방법은 11개의 칸을 지나서 상대 팀 진영에 도착했습니다.

  <img src="https://res.cloudinary.com/jistring93/image/upload/v1482130625/%EC%B5%9C%EB%8B%A8%EA%B1%B0%EB%A6%AC2_hnjd3b.png">

- 두 번째 방법은 15개의 칸을 지나서 상대팀 진영에 도착했습니다.

  <img src="https://res.cloudinary.com/jistring93/image/upload/v1482130687/%EC%B5%9C%EB%8B%A8%EA%B1%B0%EB%A6%AC3_ntxygd.png">

위 예시에서는 첫 번째 방법보다 더 빠르게 상대팀 진영에 도착하는 방법은 없으므로, 이 방법이 상대 팀 진영으로 가는 가장 빠른 방법입니다.

만약, 상대 팀이 자신의 팀 진영 주위에 벽을 세워두었다면 상대 팀 진영에 도착하지 못할 수도 있습니다. 예를 들어, 다음과 같은 경우에 당신의 캐릭터는 상대 팀 진영에 도착할 수 없습니다.

<img src="https://res.cloudinary.com/jistring93/image/upload/v1482130852/%EC%B5%9C%EB%8B%A8%EA%B1%B0%EB%A6%AC4_of9xfg.png">



게임 맵의 상태 maps가 매개변수로 주어질 때, 캐릭터가 상대 팀 진영에 도착하기 위해서 지나가야 하는 칸의 개수의 **최솟값**을 return 하도록 solution 함수를 완성해주세요. 단, 상대 팀 진영에 도착할 수 없을 때는 -1을 return 해주세요.



<br>



#### 제한사항

---

- maps는 n x m 크기의 게임 맵의 상태가 들어있는 2차원 배열로, n과 m은 각각 1 이상 100 이하의 자연수입니다.
  - n과 m은 서로 같을 수도, 다를 수도 있지만, n과 m이 모두 1인 경우는 입력으로 주어지지 않습니다.
- maps는 0과 1로만 이루어져 있으며, 0은 벽이 있는 자리, 1은 벽이 없는 자리를 나타냅니다.
- 처음에 캐릭터는 게임 맵의 좌측 상단인 (1, 1) 위치에 있으며, 상대방 진영은 게임 맵의 우측 하단인 (n, m) 위치에 있습니다.



<br>



#### 입출력 예

---

| maps                                                         | answer |
| ------------------------------------------------------------ | ------ |
| [[1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,1],[0,0,0,0,1]] | 11     |
| [[1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,0],[0,0,0,0,1]] | -1     |



<br>



#### 입출력 예 설명

---

##### 입출력 예#1

주어진 데이터는 다음과 같습니다.

<img src="https://res.cloudinary.com/jistring93/image/upload/v1482132321/%EC%B5%9C%EB%8B%A8%EA%B1%B0%EB%A6%AC6_lgjvrb.png">

캐릭터가 적의 팀의 진영까지 이동하는 가장 빠른 길은 다음 그림과 같습니다.

<img src="https://res.cloudinary.com/jistring93/image/upload/v1482130625/%EC%B5%9C%EB%8B%A8%EA%B1%B0%EB%A6%AC2_hnjd3b.png">

따라서 총 11칸을 캐릭터가 지나갔으므로 11을 return하면 됩니다.



<br>



입출력 예#2

문제의 예시와 같으며, 상대 팀 진영에 도달할 방법이 없습니다. 따라서 -1을 return 합니다.



<br>



#### 제출 코드

---

```python
from collections import deque

def bfs(starts, maps):
    answer = 0
    dirs = [(0,1), (0,-1), (1,0), (-1,0)]
    queue = deque()
    queue.append(starts)
    
    while queue:
        x, y, cnt = queue.popleft()
        maps[x][y] = 0
        for dx, dy in dirs:
            nx, ny = x + dx, y + dy
            if nx == len(maps)-1 and ny == len(maps[0])-1:
                return cnt + 1
            elif visitable(nx, ny, maps):
                maps[nx][ny] = 0
                queue.append((nx, ny, cnt+1))
    return -1

def visitable(nx, ny, maps):
    return 0 <= nx < len(maps) and 0 <= ny < len(maps[0]) and maps[nx][ny]

def solution(maps):
    return bfs((0,0,1), maps)
```

아직 탐색문제를 구현하는 것이 부족해서, 타 코드를 많이 참조해서 곱씹어가며 필사했다.

코드 설명은 아래 문제 풀이에서 진행토록 하겠다.





<br>



#### BFS, DFS에 대해

---

문제에 대한 풀이 이전, 탐색 알고리즘에서 사용되는 BFS와 DFS의 차이에 대해서 알아보고자 했다.

정확히는, 너비우선 깊이우선의 차이나 BFS는 Deque를, DFS는 Stack이나 DP를 활용해서 푼다는 것 보다 근본적인 차이가 궁금했다.

알고리즘 공부를 진행하며 사람들에게 `'이러한 문제는 어떤 게 더 적합할까요?'`라고 물어본다한들

사람들의 대답이 `BFS나 DFS나 둘다 구현 가능하니 아무거나 하나 공부해서 그거로만 푸시는게 편해요`라는 대답을 주로 들었기 때문이다.

이러한 이유로 어떨 때 BFS가, DFS가 더 적합한지 알아보고자 했다.

###### 참고 링크 : https://haams704.tistory.com/75



<br>



```
BFS
- 너비우선탐색으로 현재 나의 위치에서 가장 가까운 노드를 먼저 방문하는 것
- 방문하면서 현재 위치는 pop해주고, 방문한 곳은 체크한 뒤, 방문할 곳은 큐에 넣는 과정
- 미로 탐색과 같은 알고리즘은 최단 거리만을 가지고 탈출하는 것이기에 BFS가 더 적합
```



<br>



```
DFS
- 미로 탐색에서도 이동할 때 마다 가중치가 붙어서 이동한다거나, 이동 과정에 제약이 있을 경우 DFS가 더 적합
-> 탐색 시간은 더 걸리지만, 가중치에 대한 변수를 지속해서 관리할 수 있다는 장점이 있어 구현시 더 편리
```



<br>



위 이야기에 내가 궁극적으로 궁금했던 점들이 잘 담겨 있었다.

솔직히, 내가 아직 다양한 문제를 경험해 보지 못하여 경험치 부족인 탓에 저것들을 이해할 수 없는 것이지만

위 설명을 통해서 현재의 궁금점은 잘 정리가 되었다.



<br>



##### 현재 문제는 이동 시 어떠한 특성이 있다거나, 특별한 제약의 존재가 아닌 미로 내 최단거리를 계산하는 것이기에 BFS가 적합할 것이라 판단했다.



<br>



#### 문제 풀이

---

좌표계에서는 상,하,좌,우 한칸씩 움직이며 진행을 하기에

`dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]`을 통해 상하좌우로 더해질 좌표를 저장해놓는다.

bfs의 파라미터로 입력되는 starts라는 시작 좌표를 queue에 넣는다.

그 후, queue 내에 값이 존재하는 동안 while문을 돌며 하위 작업을 반복한다

1. starts에 입력된 (x ,y, cnt)값을 popleft를 통해 x, y, cnt 각각에 저장한다.

2. 이후, 현재 방문한 `maps[x][y]`값은 방문을 완료했기에 재방문하지 않도록 0으로 변경

3. 현재 좌표인 `maps[x][y]`에서 이동할 수 있는 4방향을 탐색하여 돌며

   기존 좌표인 `x, y`에서 이동할 수 있는 `dirs 내 x, y`값을 더해 `nx, ny`값으로 정하며

   `nx == len(maps) - 1 and ny == len(maps[0]) - 1`이면 다음에 목표에 도달하기에 return cnt+1,

    `nx, ny`가 도달하는 좌표가 아니며 방문 가능한 좌표일 경우 방문할 좌표이기에 `maps[nx][ny]`값을 0으로 변경하며 해당 좌표에 방문하여 시작하기에 start값으로서 `(nx, ny, cnt+1)`을 queue에 넣는다.

4. 만약, 목표에 도달하지 못하고 더 이상 방문할 곳이 없기에 queue가 비어서 while문을 나왔다면

   목표에 도달 할 수 없기에 -1을 return



<br>



visitable 함수의 경우, 굳이 만들지 않아도 되지만 함수명을 통해 어떤 작업을 하는지 파악함과 더불어

클린코드를 위해 별도 함수로 작성하여 아래로 빼놓았다.
